# Tree

- 비선형 구조. 원소들 간 `1:N` 관계를 가지는 자료구조이다.
- 원소들 간에 계층 관계를 가지는 **계층형 자료구조**.
- 상위 원소에서 하위 원소로 내려가면서 확장되는 트리(나무)모양의 구조.

한 개 이상의 노드(`vertax`, 하나 하나의 원소를 의미한다.)로 이루어진 유한 집합이며

- 노드 중 최상위 노드를 root라고 한다.
- 나머지 노드들은 n( 0보다 크거나 같음 )개의 분리집합 T1, ... TN으로 분리될 수 있다.

마지막 노드는 **단말노드**(또는 잎노드. leaf node. 그림 상에서 초록색)라고 부른다.

노드와 노드를 연결하는 선을 간선(edge)이라 하며, 부모 노드와 자식 노드를 연결한다.( 상단에 위치하면 부모, 하단에 위치하면 자식)

루트 노드의 경우, 부모가 존재하지 않는다.

잎노드의 경우 자식이 존재하지 않는다.

같은 부모를 가진 노드를 **형제 노드**(**sibling node**)라 한다.

한 노드를 기점으로, 간선을 따라 Root node까지 이르는 경로에 존재하는 모든 노드를 **조상 노드**라 한다.

**SubTree** : 부모 노드와 연결된 간선을 끊었을 때 생성되는 트리

**자손 노드** : 서브 트리에 있는 하위 레벨의 노드들. (자식의 자식, 자식의 자식의 자식 , ... )

### 차수 (degree)

- **노드의 차수 : 노드에 연결된 자식 노드의 수. (B의 경우 차수는 2, C의 경우 차수는 1)**
- 트리의 차수 : 트리에 있는 **노드의 차수** 중에서 가장 큰 값. 위 예시를 보면 트리의 차수는 D 노드의 차수인 3임을 알 수 있다.
- 잎 노드 : **차수가 0인 노드. 자식 노드가 없는 노드**

### 높이 ( LEVEL )

- 노드의 높이 : 루트에서 노드에 이르는 간선의 수. ( B의 경우 높이는 1, F의 경우 높이는 2)
- 트리의 높이 : 트리에 있는 노드의 깊이 중에서 가장 큰 값. 최대 레벨 ( 위 예시의 경우 트리 T의 높이는 3이다. )

- Root node의 level은 0이다.

## 이진 트리

- 모든 노드들이 최대 2개의 서브트리를 갖는 특별한 형태의 트리.
- 각 노드가 자식노드를 최대한 2개까지만 가질 수 있는 트리.
- 왼쪽 자식 노드와 오른쪽 자식 노드로 구성된다. (left child node, right child node)

- 자식이 아예 없는 경우에도 이진트리에 속한다.

- 레벨 i에서 노드의 최대 개수는 **2^i**개이다.

- 높이가 h인 이진 트리가 가질 수 있는 노드의 최소 개수는 `h+1` 개가 되며, 최대 개수는 

`2^(h+1) - 1` 개가 된다. ( 각 LEVEL에 따라 점차 증가하는 노드의 개수는 1,2,4,8, ... 이다. )

### 포화 이진 트리 (Full Binary Tree)

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/444afe47-161e-44a7-a104-4555bce46b5f/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/444afe47-161e-44a7-a104-4555bce46b5f/Untitled.png)

- 모든 레벨에 노드가 포화상태(2개)로 차 있는 이진 트리.
- 높이가 h일 때, 최대 노드 개수인 `2^(h+1)-1` 개의 노드를 가진 이진 트리.
- 루트를 1번으로 할 때,  `2^(h+1)-1` 까지 정해진 위치에 대한 노드 번호를 가짐.

### 완전 이진 트리 (Complete Binary Tree)

- 높이가 h이고 노드 수가 n개 일 때, 포화 이진 트리의 노드 번호 1번부터 n번까지 빈 자리가 없는 이진 트리.

- 마지막 레벨까지 꽉 차있지는 않다. 꽉 차있지 않을 때는 중간에 빈 노드번호가 발생해선 안된다!

### 편향 이진 트리

- 높이 h에 대한 최소 개수의 노드를 가지면서, 한쪽 방향의 자식 노드만을 가진 이진 트리
- 왼쪽 편향 이진 트리
- 오른쪽 편향 이진 트리

구조적으로 리스트와 동일하며, 이진 트리의 장점을 잃어버린 녀석이다.

### 이진 트리 - 순회 (Traval)

- 트리의 각 노드를 중복되지 않게 전부 방문하는 것을 말하는데, 트리는 비 선형구조이기 때문에 선형 구조에서와 같이 선후 연결 관계를 알 수 없다.

순회란, 트리의 노드들을 체계적으로 방문하는 것을 말한다.

- **전위순회** : 부모 노드를 먼저 처리하고, 자식 노드를 좌, 우 순서로 방문한다.
- **중위순회** : 왼쪽 자식노드, 부모노드, 오른쪽 자식노드 순으로 방문한다.
- **후위순회** : 자식노드를 좌우 순서로 방문한 후, 부모 노드를 방문한다.

### 전위 순회

1. 현재 노드 n을 방문하여 처리한다. → V
2. 현재 노드 n의 왼쪽 서브트리로 이동한다. → L
3. 현재 노드 n의 오른쪽 서브트리로 이동한다. → R

```python
def preorder_traverse(T): # 전위순회
    if T: # T is not None. 유효한 노드라면 처리한다.
        visit(T) # 방문 처리
        preorder_traverser(T.left) # 왼쪽 서브 트리로 이동
        preorder_traverse(T.right) # 오른쪽 서브 트리로 이동
```

### 중위 순회

### 후위 순회

### 배열을 이용한 이진 트리의 표현

- 이진 트리에 각 노드 번호를 다음과 같이 부여한다.
- 루트의 번호를 **1번**으로 한다. ( 일반적으로 인덱스는 0번으로 시작하는 것과 대조적이다. )
- 레벨 n에 있는 노드에 대해, 왼쪽부터 오른쪽으로 `2^n` 부터 `2^n+1-1`까지 번호를 차례대로 부여한다.

트리를 리스트에 저장할 때, 항상 0번째 인덱스는 비어 있다.

- 노드 번호가 i인 노드의 부모 노드의 번호는 `i // 2`이다. floor 연산 ! 

- 노드 번호가 i인 노드의 왼쪽 자식 노드 번호는 `2*i` 이다.

- 노드 번호가 i인 노드의 오른쪽 자식 노드 번호는 `2*i +1`이다. 

- 레벨이 n인 계층에 대해 시작 노드 번호는 `2^n`이다. 

Python에선 int(-3/2) 와 -3//2의 결과가 서로 다르다. → -1과 -2

### 연습문제

- 첫 줄에는 트리의 정점의 총 수 V가 주어진다.
- 그 다음 줄에는 V-1개 간선이 나열된다.
- 간선은 항상 "부모 자식"순서로 표기된다.
- 간선은 부모 정점 번호가 작은 것부터 나열되고, 부모 정점이 동일하다면 자식 정점 번호가 작은 것부터 나열된다.

1 2 1 3 2 4 3 5 3 6 4 7 5 8 5 9 6 10 6 11 7 12 11 13

이 때 전위 순회했을 때 방문 순서를 출력하시오.

### 트리 인접관계 작성하기

```python
N = int(input())
arr = list(map(int, input().split())) 
child = [[0]*2 for _ in range(N+1)]

# child의 한 인덱스는 [0,0] 와 같이 2개의 원소를 갖는 리스트로 구성되며
# 왼쪽은 왼쪽 자식 노드, 오른쪽은 오른쪽 자식 노드를 의미한다.
# 자식 노드 인접 관계를 작성하면서, 왼쪽이 비어있으면 우선적으로 왼쪽에 먼저 넣는다.

# 인접행렬 작성하기
for i in range(N-1):
    if child[arr[i*2]][0] == 0: # 왼쪽 노드 공간이 비어있다면. i*2로 하는 이유 : 부모 - 자식순으로 출력되기 때문에
        child[arr[i*2]][0] = arr[i*2+1]
    else: # 왼쪽 자식 노드가 이미 존재한다면
			  child[arr[i*2]][1] = arr[i*2+1]
```

이제 전위순회를 하는 함수를 작성해보자.

```python
# 입력 예
# 3
# 1 2 1 3

# 13
# 1 2 1 3 2 4 3 5 3 6 4 7 5 8 5 9 6 10 6 11 7 12 11 13

# n이 최대 노드 번호보다 작은지도 검사해야 한다.
def preorder(n): # 전위 순회
    if n!=0: 
        print(n, end=" ")
        preorder(child[n][0])
        preorder(child[n][1])

def inorder(n): # 중위 순회
    if n!=0:
        inorder(child[n][0])
        print(n, end=" ")
        inorder(child[n][1])

def postorder(n): # 후위 순회
    if n!=0:
        postorder(child[n][0])
        postorder(child[n][1])
        print(n, end=" ")

N=int(input())
arr=list(map(int, input().split()))
child=[[0]*2 for i in range(N+1)]

for i in range(N-1):
    if child[arr[i*2]][0]==0:
        child[arr[i*2]][0]=arr[i*2+1]
    else:
        child[arr[i*2]][1] = arr[i*2 + 1]

print("전위 순회 결과:", end=" ")
preorder(1)
print()

print("중위 순회 결과:", end=" ")
inorder(1)
print()

print("후위 순회 결과:", end=" ")
postorder(1)
print()
```

포화이진트리 배열을 이용한 이진트리의 표현의 단점 :

- 편향 이진 트리의 경우에 사용하지 않는 배열 원소에 대한 메모리 공간 낭비가 발생한다.
- 트리의 중간에 새로운 노드를 삽입하거나, 기존의 노드를 삭제할 경우 배열의 크기 변경이 어려워 비효율적이다.

### 트리의 저장 방법1

- 6 : 1에서 6번까지 노드 번호가 존재하며, 단 포화 이진 트리를 따르지는 않는다.
- 1 2 1 3 2 4 3 5 3 6 (ROOT 번호가 항상 1번이지는 않다. )

1. **부모 노드를 인덱스로 자식 번호를 저장한다.**


```python
# 부모 p, 자식 c
if ch1[p] == 0: # 왼쪽 노드가 비어있다면
    ch1[p] = c
else: # 왼쪽 노드가 이미 존재한다면
    ch2[p] = c
```

순회는 subTree의 ROOT node부터 해도 상관 없다. ( **다만, 순회의 범위는 항상 root node까지만이다. 그 이상을 거슬러 올라가지는 않는다.** )

### 트리의 저장방법2

- **자식 노드를 인덱스로 부모 번호를 저장한다.**

이 경우 root는 부모가 없는 노드이다.

예) 4의 경우 부모는 2이므로, par 리스트의 4번 인덱스에 2를 저장한다.

- 위 Tree의 전위 순회 순서는 : **1 2 4 3 5 6** 

## 수식 트리

- 수식을 표현하는 이진 트리.
- 수식 이진 트리라고 부르기도 함.
- 연산자는 루트 노드이거나 가지 노드
- 피연산자는 모두 잎 노드

## 이진 탐색 트리 : 규칙을 갖는 이진 트리!

- 모든 원소는 서로 다른 유일한 키를 갖는다.
- **key(왼쪽 subTree) < key(루트 노드) < key(오른쪽 서브트리)**
- 왼쪽 서브트리와 오른쪽 서브트리도 이진 탐색 트리이다.
- 중위 순회 하면 오름차순으로 정렬된 값을 얻을 수 있다.

### 탐색 연산

- 루트에서 시작한다.
- 탐색할 키 값 x를 루트 노드의 키 값과 비교한다.

- 장점 : **오름차순된 선형 리스트에서 탐색할 때보다 빠르게 탐색할 수 있다.**

- 단, 편향 이진 트리로 저장된 경우에는 선형 리스트에서 탐색했을 때와 동일하다.

### 삽입 연산

- 삽입할 원소와 같은 원소가 트리에 있으면 삽입할 수 없으므로, 같은 원소가 트리에 있는지 탐색하여 확인한다.
- 탐색에서 탐색 실패가 결정되는 위치가 삽입 위치가 된다.


### 이진 탐색 트리의 성능

- 탐색, 삽입, 삭제 시간은 트리의 높이만큼 시간이 걸린다. ( 시간 복잡도 : O(h), h는 트리의 깊이)
- 평균의 경우
- 최악의 경우

참고) `red black tree` , `다차원트리`, `KD트리`, `KDB트리`, `R트리`

`그리드 파일`, ...

### 이진 탐색 트리의 삭제

- 13을 지우는 경우에는 자식 노드가 없는 경우이므로 삭제하기 용이하다.
- 12를 삭제하는 경우, 연결 리스트 형태에서 9, 15의 연결되는 노드 주소를 수정하면 된다.
- 9를 삭제한다면..? 양쪽에 자식이 있는 경우에는 오른쪽으로 가서, 9보다 큰 숫자 중에서 왼쪽으로만 탐색해서 왼쪽 자식이 없는 최초의 대상으로 교환한다.

# Heap

- **완전 이진 트리**에 있는 노드 중에서 키 값이 가장 큰 노드나 키 값이 가장 작은 노드를 찾기 위해서 만든 자료구조
- 최대힙
- 최소힙

### 힙 연산 - 삽입


- 최대힙에서 23을 삽입하는 경우 : 부모와 자식 간의 값을 비교하여, **교환**할 수도 있다.

- 힙의 경우 선형 리스트로 표현하기 쉽다!

### 힙 연산 - 삭제

- 힙에서는 루트 노드의 원소만을 삭제할 수 있다.
- 루트 노드의 원소를 삭제하여 반환한다.
- 힙의 종류에 따라 최대값 또는 최소값을 구할 수 있다.

**힙은 반드시 완전 이진 트리를 유지해야 한다.** 따라서 리스트의 **가장 마지막 값**을 루트 노드에 채운다. 이후 최대힙 또는 최소힙에 따라 부모 - 자식 값을 비교하여 교환하는 과정을 거친다. 

**힙의 키를 우선순위로 활용하여 우선순위 큐를 구현할 수 있다.**

예제) 

```python
5 4 # 1번부터 5번까지의 노드. 4개의 간선
2 1 2 4 4 3 4 5

def preorder(n):
    if n > 0:
        print(n, end=' ')
				preorder(left[n])
				preorder(right[n])

V, E = map(int, input().split())
edge = list(map(int, inpit().split()))

left = [0]*(V+1) # 왼쪽 자식 번호(부모를 인덱스로)
right = [0]*(V+1)

pa = [0] * (V+1) # 자식을 인덱스로 부모 번호를 저장한다.

for i in range(E):
    n1, n2 = edge[i*2], edge[i*2+1] # n1 부모, n2 자식 노드
    if left[n1] == 0: # 왼쪽 자식이 없으면
        left[n1] = n2 # 부모를 인덱스로 자식 번호를 저장한다.
    else: # 왼쪽 자식이 있으면
        right[n1] = n2 # 부모를 인덱스로 자식 번호를 저장한다.

    pa[n2] = n1 # 자식을 인덱스로 부모 번호를 저장한다.

root = 0
for i in range(1, V+1):
    if pa[i] == 0:
        root = i # 0이면 부모이다.
        break
        
preorder(root)
```